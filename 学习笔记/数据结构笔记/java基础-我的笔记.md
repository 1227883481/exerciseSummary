知识笔记

# java基础

## 面向对象（上）-基础知识

+ 创建 main 有快捷键：psvm ,即 public static void main(String[] args){                                                     }

+ 创建输出有快捷键：sout 即 System.out.println()

+ 快速创建一个对象，只需输入new String（）按回车，就能输入对象的名字，以快速创建对象。创建对象即类的实例化，实例化一个类

+ 方法里的参数和形参都叫局部变量；局部变量与属性（成员变量）相对应

+ 对于类文件里的主函数，也看作一个方法，在下面（在同一个类中）创造一个方法之后，也可以对这个大类进行实例化，在main中也正常调用下面创造的方法。

+ 快速创建一个for循环的快捷键为：（必须在一个方法里才可以用）fori提示出来第一个就是一般循环体。iter比较复杂的一种循环

+ 在引用型变量里边，直接输出这个变量，它不是null就是地址值。当new过对象（变量）之后，他就开辟了一个对应大小的空间，此时该变量存放的就是地址值、

+ 为什么某一行直接调用方法不行呢？是可以的刚才不行是因为 对象数组.方法 了，实际上应该 对象数组【i】.方法 

+ 有时代码对了但是打印不出来是因为 随机生成的数里没有这个，如age == 15

+ 方法中的局部变量是暂时存储在栈空间中的；随着方法的结束，变量也出栈。

+ 方法中不可以再定义方法

+ 匿名方法只能调用一次，一般是传入形参时为了省事采用匿名方法。

+ 方法中：当形参有多个时，可变形参必须放在最后，并且最多只有一个（int a, String... str）

  ```java
  public class ArrayTest {
  public static void main(String[] args) {
  int[] i = new int[10];
  System.out.println(i);
  char[] c = new char[10];
  System.out.println(c);
  }
  }
  ```

  这个题目输出应该为地址值和null而并非两个地址值，原因是方法println（）里的形参为char型数组时，直接就有一个专门的方法，让他输出整个char型数组。输出的为char型数组的遍历。（属于一个冷门的小知识）【疑问-已解决】递归的时候，发现方法内部可以不创建对象就可以调用本身。也可以调用其他不带主函数的方法（在不创建对象的方法下），但是在main方法中就不行，必须创建对象。先不考虑在main中的那些特殊。实际上是this.getSum，其中this代表当前对象，在用的时候省略了。

+ 【经验】关于内存解析图的理解：在使用一个方法有形参时，一定会有先在栈空间中声明定义形参的过程，所以有时变量名相同也要有新生成的结构（比如我的第一个内存结构图中的v的迷惑解除），当方法结束时，这些方法中的变量会移除栈。

+ 【新知识】类中的属性用权限修饰符private修饰时，用【对象.属性】的方式就不能对他进行调用了，比如我的第一个例子 legs，这个例子中通过一个方法进行赋值，因为方法是public的，因此可以间接的使用legs这个属性。

+ 【经验】对于一个属性私有化之后，要完整的实现这个int属性通常包括两个部分，即用两个方法：get值和set值，来保证原有功能不缺失。

+ 【经验】亲身试验过，缺省default只能在同一个包下引用，即使一个大包里面有好几个小包，那也只能在同一个小包下面。

+ 【新知识】构造器相关知识# 目前我的理解有两个用处

  1. 构造对象必须，可以初始化属性值（规定这个人生来要洗澡）
  2. 会自带，是造对象的必须。

+ 【新知识】属性赋值的先后顺序
  1.默认初始化  即 没赋值的时候int是0
  2.显式初始化  int age = 10
  3.构造器赋值   
  4.通过 方法 或者 对象.属性 的方式赋值（其实自然而然，没必要记）

+ 【新知识】javaBean一个类满足以下三个特征称为JavaBean。是一种用java语言写成的可重用组件。
  1.类时公共的 public
  2.有一个无参的构造器
  3.有属性，且有对应的get set方法

+ 【新知识】this
  1.当需要赋值的属性与形参重名时，this用来区分，表示是这个对象的属性。此时不可省略this

  ```java
  public void setName(String name) {
  this.name = name;
  }
  ```

  2.构造器内部调用其他构造器时，使用方式为

  ```java
  public Person2(String name,double height,int age,String family){
  this(name,height,age);
  this.family = family;
  }
  ```

  

+ 【经验】在创建对象时用了一个构造器，发现赋值年龄时提示换成二进制，因为在这个值前面不小心逗号写成了汉语模式，因此一直报错。

+ 【新知识】project2中经常忘记的规范：

  1.有时候先创建几个变量，将他们赋给一个对象，在调用添加/替换功能

  2.有时候经常忘记，判断时某些步骤已经实现了一遍了

+ 【新知识】java中继承只能继承一个父类，想继承多个类的功能后续再解决，暂时先不能。但可以继承好几代。
+ 【总结】重写与重载
  重载："两同一不同":同一个类、相同方法名；参数列表不同：参数个数不同，参数类型不同
  重写：子类重写的方法名和形参列表和父类被重写的==方法名和形参列表==相同
  总结见daily note的总结
+ 【总结】构造器中的使用
  this(age,name)和super(age,name)很相似，this是可以继承本类中之前声明的几个；super是可以继承父类声明的几个构造器，都必须在构造器的首行，所以不能同时存在 。 

+ 【遗忘】多态创建之后，Person p =  new Man;编译时看左边，运行时看右边。但对于属性来说都看左边，你都把他定义为Person类了，你的属性也就是要看他的了。

+ 【遗忘】面试题：

  1.编译时看左边运行时看右边，表现为 先编译，运行时看一看是否重写了，如果重写了就运行重写之后的。
  2.int...arr和int[] arr完全相同。故相当于重写

  （重写的概念：两个方法**方法名和参数完全相同，知识方法体内部不一样**，修饰符和返回值类型满足一个大小关系，一般用得少）

  3.确定参数的优先调用。

![image-20201217210832588](C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20201217210832588.png)

+ 【新知识】包装类的转换
  1.基本数据类型变包装类，传统方法可以new一个类，参数直接是这个数
  	即 Integer int1 = new Integer(11);
  	但是可以直接Float f = 13.0; 来自动装箱
  2.包装类转换为基本数据类型，传统方法可以调用类中的方法xxxValue
  	int num1 = int1.intValue();
  	但是也可以直接 int num1 = int1；自动拆箱

  3.包装类到string，调用包装类的tostring()方法，tostring存在于最强父类object中，任何类都有。
  4.string 到包装类，与1相同，new
  String s = new String("tom");
  
  5.基本数据类型到string，调用string重载的valueOf
     string.valueOf(12);  此时返回值为string
6.string转换为基本数据类型；
    调用包装类中的一个本来存在的方法，Boolean.parseBoolean(str)，再用一个基本数据类型接收一下
  
+ 【经验】直接输出一个包装类，比如double的包装类，不会显示地址值，而是将他看成了double，输出了内容13.0
  对于输出，基本都是如果涉及到了包装类，就是输出的值而不是地址值。
  但是如果要进行运算则必须要转化为基本数据类型才可以。

  ```java
  Object obj1 = new Integer(15);
  System.out.println(obj1.getClass()); //此时显示为Integer类型
  System.out.println(obj1);	//输出的是15，因为1.实际运行时仍然把object看做为Integer类型的，又有输出语句带有自动类型转换，换为整数输出了。
  ```
```
  Object obj1 = new Integer(15);
  int ob1 = (Integer) obj1;
  System.out.println(ob1 + 1); //强转为int或者Integer都可以
```

  其实就跟string一样，java为了方便，输出时都是显示的实际字符内容。 
  ==追溯==：找到最终的根源：其实println方法里面输出时，调用的是当前对象的toString方法然后输出的是字符串，对于一般的类，toString输出的是地址值，对于基本数据类型的包装类，他们对toString进行了重写，输出的是实体内容。类似的还有string类，Date,File等。

## 面向对象下

+ 【新知识】static修饰的变量为类变量，也叫静态变量。一般的为实例变量（不以static修饰）	。static不能修饰构造器

+ 【新知识】static修饰的变量随着类的加载而加载，因此可以把创建对象直接类.静态属性。静态变量在内存中只存在一份，存在于方法区的静态域中。  

+ 【新知识】main的使用
  main相当于一个普通的方法，只不过它是规定的入口。public是因为虚拟机要调用这个类里的main方法，应权限大一些；static是因为他是一个入口，首先要能够调用，即使没有创建对象也能调用，不然就不能进入了，所以要事先加载。void是因为该方法结束之后，程序也结束了，不需要返回。string[] args是一个数组形参，main方法的也可以作为一种与控制台交互（可以简单理解为输出）的方式（除了scanner之外）。
  我还查了一下项目二的CMUtility，readkeyboard果然追根溯源到了scanner，说明确实scanner是一种基本的输出方式或交互方式。

+ 【新知识】代码块。对于静态代码块（有static修饰的）， 随着类的加载而执行。

  对于非静态代码块，没创建一个对象都只醒一次，相当于每次用到都自动执行的一个方法。它的作用就是可以在创建对象时进行一些操作。
  对于代码块，其实自己写代码不经常用的到，主要是看源代码时会看到别人用这个写，所以要知道。

+ 【记错】非静态代码块先于构造器执行，它的顺序与属性的显式赋值同时发生，谁在前面谁先执行。

+ 【理解】final修饰形参时，如果传入一个对象，则说明这个对象在这个方法中不能变，但其中的属性可以再次操作变化。可以这么理解：对象的地址值不变，但是指向的内存空间中的属性等可以变，final限制的是地址值内容不变，即不能再重新指向一个新对象。

+ 【经验】有的时候写方法，他写返回值为void会报错，这是因为这个方法名字可能与类中的自带的经典的方法重名，他判断为你在重写方法，比如我遇到的一个toString.

+ 【记忆】class AA extends BB implements CC, DD
  接口可以多继承，接口可以继承多个接口。
  
+ 【理解】如果一个类继承了两个接口，里边有两个同名的抽象方法，此时重写该方法，认为是对两个都重写了，谁让他们重名了呢。 

+ 【复习】接口中有默认的方法时，调用多个接口会产生冲突，此时要精确调用接口中的各默认方法，语句为
  interface1.super.help();

+  【复习】接口可以多继承，即指的是接口之间可以

  ```java
  A extend B, C
  ```

  此时A要实现BC的所有抽象方法。

+ 【复习】形参也可以声明为接口（USB那个例子），此时体现接口的多态性。因为接口不能实例化，因此实参里传入的都是继承该接口的对象（比如对USB 的实现之后的flash）。

+ 【复习】静态方法不能重写。

+ 【复习】java8以后接口中可以定义静态方法和默认方法。接口中静态方法存在的意义，供自己用，只能通过接口来调用，其他实现类里完全看不到这个方法。

+ 【复习】容易混淆的，内部类外部类中有同名参数时的表示方法。

![image-20201225121944450](C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20201225121944450.png)

#### 异常

+  【知识】异常也是一个对象。处理异常的方式：抛抓模型。
  一旦出现异常，就在异常代码处出现一个对应异常类的对象，并将对象抛出，其后的代码不再执行（意思是try大括号内部的异常 后面的代码）

+ 【记忆】出现异常之后，在方法体内可以这样：
  1.输出 getMessage( );  因为这个方法返回的是string
  2.调用一个方法 e.printStackTrace( )

+ 【知识】继承时，子类抛出的异常类型不能大于父类抛出的异常类型。

+ 【经验】自己写异常时只需要用到  Exception 用于处理编译时的异常，RuntimeException用于运行时的异常。
+ 【经验】异常或者正常的方法要结束出去的时候（比如要return了，要抛出一个异常了），如果此时有个Finally，则会在返回值之前执行Finally，此时若Finally里面有返回，则从此处返回。

#### 项目三的疑问

+ PC是构造器还是方法？getdescription在哪重写呢？
  构造器，因为同名，而且合乎常理，在类图中看着像方法而已；后面总会用到的。
+ 重写String快捷键
  是跟构造器get set一样的快捷方式
+ 异常处理那块不熟：抛出异常在哪个位置，如何定义自己的异常，带有输入信息
  已熟，简单

# java高级

## 一、常用类

### string类

【知识】对于String str = "abc" 

### 枚举类

【找bug】枚举类在最后半个大括号一直红色波浪线报错，导致下面test也没有办法使用@test进行测试。

找到了原因，是因为Test测试只能在一个类里面，我这出现在了类外面。

![image-20210309105805844](C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20210309105805844.png)

【bug】Collection coll = new ArrayList();这个明明一样为什么还报错：
原来是与自己建的类重名了，自己建的类名一定要避开已有类！

## 二、集合

【知识】native关键字：native 关键字告诉编译器（其实是JVM）调用的是该方法在外部定义。比如

```java
public native int hashCode(); //hashCode方法，底层调的是C写得hash方法
```









**java对象**

关于第一个对象，语言时为什么不能输入system.in
创建我的第一个类：人

先创建一个类，设计类的成员：具体步骤为
先定义变量，即属性；         
再定义方法，即类似于函数；

第二步，创建类的对象，即实例化，Person p1 = new Person();  //小括号容易掉第三步，通过 对象.属性 对象.方法 调用对象的结构：p1.age = 30;

**对象的内存解析** 

![Image](C:\Users\wang\AppData\Local\Temp\Image.png)

##### 类的设计中，两个重要结构之一：属性

对比：属性 vs 局部变量

1. 相同点：

+ 1.1 定义变量的格式：数据类型 变量名 = 变量值
+ 1.2 先声明，后使用
+ 1.3 变量都其对应的作用域

2. 不同点： 

   2.1 在类中声明的位置的不同
   属性：直接定义在类的一对{ }内
   局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量

   2.2 关于权限修饰符的不同

   属性：可以在声明属性时，指明其权限，使用权限修饰符。
   常用的权限修饰符：private、public、缺省、protected --->封装性
   目前，大家声明属性时，都使用缺省就可以了。
   局部变量：不可以使用权限修饰符。
   2.3 默认初始化值的情况：
   属性：类的属性，根据其类型，都默认初始化值。
   整型（byte、short、int、long：0）
   浮点型（float、double：0.0）
   字符型（char：0 （或'\u0000'））
   布尔型（boolean：false）
   引用数据类型（类、数组、接口：null）
   局部变量：没默认初始化值。
   意味着，我们在调用局部变量之前，一定要显式赋值。
   特别地：形参在调用时，我们赋值即可。
   2.4 在内存中加载的位置：
   属性：加载到堆空间中  （非static）
   局部变量：加载到栈空间

   **类中的方法 创造的步骤**

   方法定义分为五部分：权限修饰符；返回值类型；方法名 ；形参；方法体：方法功能的实现。

   **return的使用**

   结束一个方法；返回类型值；注意后面不能加执行语句，相当于方法中的break.   

### 面向对象整理

+ 方法的重载只要方法所在类相同，方法名相同，但参数列表不同；就称为方法的重载。跟修饰权限，返回值类型都无关。 
+ java形参的传递机制：值传递机制