## 二叉排序树

【坚定一个信念】二叉树中，左子节点以及他们的子节点一定比我小，右边一定比我大。

【经验】方法需要递归时，比如查找，写代码时先无需深度考虑，先抓住一层考虑，写出来，最后再补。这样写起来比较痛快

**理解**：二叉排序树就是按照数字的大小建立的树，中序遍历可以得到一个有顺序数字序列

**优点**：插入和遍历都比较方便

**代码实现思路**：添加方法中，只需判断大小的逻辑。

判断二叉树是否为空，如果为空，就直接添加

否则调用add方法

+ add方法的逻辑：
  首先判断当前节点是否为空。
  若不为空，判断与当前节点大小，
  if小了，if左子节点不为空，调用左子节点添加方法，
  else大了，右子节点不为空，进入右子节点添加的方法。（递归）
  递归的终止条件为，如果是空，添加到这个位置。

**中序遍历思路**：

+ 判断是否为空，若空，提示二叉树为空
+ 如果左子节点不为空，就调用左子节点的遍历方法
+ 输出当前节点
+ 如果右子节点不为空，调用右子节点遍历方法

**二叉树删除**：

+ 考虑多种情况：1.待删除（targetNode)为叶子节点；2.targetNode只有一个左子树或右子树；3.有两个子树

+ 利用targetNode的父节点parentNode作为辅助
+ 面向对象，每一个功能分别实现

具体步骤

+ 先找到待删除的节点（写一个方法实现）
+ 找到待删除节点targetNode的父节点（此时的前提是targetNode是二叉树里的节点，所以一定能找到该节点）
  + 每一个if之前一定要先判断节点是否为空，防止空指针异常
  + 如果某一个节点的左子或者右子为targetNode，则该节点就是要返回的父节点，此时返回该节点（递归的终止条件）
  + 如果tar小于该节点并且左子节点不为空，就递归（前提已经有了：一定能找到targetNode），同理右子节点也是。
  + 以上都不满足，则没有父节点（targetNode为根节点）
+ 确定是哪一种情况，即：
+ 如果是targetNode是叶子节点，就判断是左子节点还是右子节点，直接让parentNode对应位置置空
+ 如果是targetNode有两个子节点，就先找到左子节点的最大值，将其放在这个位置，原来位置的该点置空。
  + 写一个方法如下，功能是 输入一个节点，找到以输入节点为根节点的二叉树最大值，并将其输出并删除。
  + 如果右子节点不为空，就一直递归，直到找到最后面的那一个，输出，并置为空

+ else就是有一个叶子节点的情况。判断targetNode是parent的左子节点还是右子节点，如果是左子节点就将左子节指向仅有targetNode的那一个子节点。
  如果没有父节点，说明待删除的是根节点，就将根节点的对应节点设置为targetNode的子节点。

